import os
import uuid
from typing import Optional, Tuple, List
from app.core.config import get_settings
from app.services.file_manager import FileManager
from app.services.audio_processor import AudioProcessor

class TTSService:
    def __init__(self):
        self.settings = get_settings()
        self.file_manager = FileManager()
        self.audio_processor = AudioProcessor()

    async def synthesize(
        self,
        text: str,
        project_id: Optional[str] = None,
        prompt_speech_path: Optional[str] = None,
        prompt_text: Optional[str] = None,
        output_format: str = "wav",
        split_sentences: bool = False
    ) -> Tuple[str, str]:
        """
        合成单个文本为语音
        
        参数:
            text: 要合成的文本
            project_id: 项目ID，如果为空则生成新的
            prompt_speech_path: 提示语音文件路径
            prompt_text: 提示文本
            
        返回:
            (project_id, 生成的音频文件路径)
        """
        if not project_id:
            project_id = str(uuid.uuid4())
            
        order = self.file_manager.get_next_order_index(project_id)
        project_path = self.file_manager.get_project_path(project_id)
        
        # 构建Spark-TTS命令行
        cmd = [
            os.path.join(self.settings.SPARK_TTS_ROOT_DIR, ".venv", "bin", "python"),
            "-m",
            "cli.inference",
            "--model-dir", self.settings.SPARK_TTS_MODEL_DIR,
            "--device", str(self.settings.SPARK_TTS_DEVICE),
            "--text", text,
            "--save_dir", project_path
        ]
        
        # 使用提供的参数或默认值
        final_prompt_speech = prompt_speech_path or self.settings.DEFAULT_PROMPT_SPEECH_PATH
        final_prompt_text = prompt_text or self.settings.DEFAULT_PROMPT_TEXT
        
        if final_prompt_speech:
            cmd.extend(["--prompt-speech", final_prompt_speech])
        if final_prompt_text:
            cmd.extend(["--prompt-text", final_prompt_text])
            
        # 执行命令
        import subprocess
        try:
            result = subprocess.run(
                cmd,
                check=True,
                capture_output=True,
                text=True
            )
            if result.returncode != 0:
                raise RuntimeError(f"Spark-TTS failed: {result.stderr}")
                
            # 读取生成的WAV文件（Spark-TTS会自动生成带时间戳的文件名）
            wav_files = [f for f in os.listdir(project_path) if f.endswith('.wav')]
            if not wav_files:
                raise RuntimeError("No WAV file generated by Spark-TTS")
            temp_output_path = os.path.join(project_path, wav_files[-1])  # 取最新生成的文件
            with open(temp_output_path, "rb") as f:
                audio_data = f.read()
            
            # 保存音频文件
            final_path = self.file_manager.save_audio(
                audio_data,
                project_id,
                order,
                output_format if output_format != "wav" else "wav"
            )
            
            # 如果需要格式转换且不是WAV格式
            if output_format != "wav":
                converted_path = self.audio_processor.convert_format(
                    final_path,
                    output_format
                )
                os.remove(final_path)  # 删除原始WAV文件
                final_path = converted_path
            
            return project_id, final_path
        except subprocess.CalledProcessError as e:
            raise RuntimeError(f"Spark-TTS execution failed: {e.stderr}")
        except Exception as e:
            if os.path.exists(temp_output_path):
                os.remove(temp_output_path)
            raise
        
        return project_id, output_path

    async def synthesize_multiple(
        self,
        sentences: List[str],
        project_id: str,
        prompt_speech_path: Optional[str] = None,
        prompt_text: Optional[str] = None,
        output_format: str = "wav"
    ) -> Tuple[str, List[str]]:
        """
        合成多个句子为语音
        
        参数:
            sentences: 句子列表
            project_id: 项目ID
            prompt_speech_path: 提示语音文件路径
            prompt_text: 提示文本
            
        返回:
            (project_id, 生成的音频文件路径列表)
        """
        output_files = []
        for sentence in sentences:
            _, output_path = await self.synthesize(
                sentence,
                project_id,
                prompt_speech_path,
                prompt_text,
                output_format
            )
            output_files.append(output_path)
            
        return project_id, output_files